<!DOCTYPE html>
<html lang="ru">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link rel="stylesheet" href="css/style.css" />
    <title>lesson_3</title>
  </head>
  <body>
    <header></header>
    <main class="content">
      <div class="whyGit">
        <h4>Почему Git?</h4>
        <p class="text">
          а полноценным обсуждением всех достоинств и недостатков Git в
          сравнении с централизованными системами контроля версий обращайтесь к
          всемирной сети. Там Вы найдёте достаточное количество споров на эту
          тему. Лично же я, как разработчик, на данный момент предпочитаю Git
          всем остальным инструментам. Git реально смог изменить отношение
          разработчиков к процессам слияния и ветвления. В классическом мире
          CVS/Subversion, из которого я пришёл, ветвление и слияние обычно
          считаются опасными («опасайтесь конфликтов слияния, они больно
          кусаются!»), и потому проводятся как можно реже.
        </p>
        <p class="text">
          Но с Git эти действия становятся исключительно простыми и дешёвыми, и
          потому на деле они становятся центральными элементами обычного
          ежедневного рабочего процесса. Просто сравните: в книгах по
          CVS/Subversion ветвление и слияние обычно рассматриваются в последних
          главах (для продвинутых пользователей), в то время как в любой книге
          про Git они бывают упомянуты уже к третьей главе (основы).
        </p>
        <p class="text">
          Благодаря своей простоте и предсказуемости, ветвление и слияние больше
          не являются действиями, которых стоит опасаться. Теперь инструменты
          управления версиями способны помочь в ветвлении и слиянии больше, чем
          какие-либо другие.
        </p>
        <p class="text">
          Но хватит говорить об инструментах, давайте перейдём к модели
          разработки. Модель, которую я хочу представить, — это, по сути, просто
          набор процедур, которые исполняет каждый член команды, чтобы все
          вместе могли достичь высокой управляемости процесса разработки.
        </p>
      </div>
      <div class="decentralized">
        <h4>Децентрализованный, но централизованный</h4>
        <p class="text">
          Предлагаемая модель ветвления опирается на конфигурацию проекта,
          содержащую один центральный «истинный» репозиторий. Замечу, что этот
          репозиторий только считается центральным (так как Git является DVCS, у
          него нет такой вещи, как главный репозиторий, на техническом уровне).
          Мы будем называть этот репозиторий термином origin, т.к. это имя и так
          знакомо всем пользователям Git.
        </p>
        <img src="img/schema.png" alt="" />
        <p class="text">
          Каждый разработчик забирает и публикует изменения (pull & push) в
          origin. Но, помимо централизованных отношений push-pull, каждый
          разработчик также может забирать изменения от остальных коллег внутри
          своей микро-команды. Например, этот способ может быть удобен в
          ситуации, когда двое или более разработчиков работают вместе над
          большой новой фичей, но не могут издать незавершённую работу в origin
          раньше времени. На картинке выше изображены подгруппы Алисы и Боба,
          Алисы и Дэвида, Клэр и Дэвида.
        </p>
        <p class="text">
          Технически это реализуется несложно: Алиса создаёт удалённую ветку Git
          под названием bob, которая указывает на репозиторий Боба, а Боб делает
          то же самое с её репозиторием.
        </p>
      </div>
      <div style="color: darkblue" class="mainBranches">
        <h4>Главные ветви</h4>
        <p class="text">
          Ядро модели разработки не отличается от большинства существующих
          моделей. Центральный репозиторий содержит две главные ветки,
          существующие всё время.
        </p>
        <ul>
          <li>master</li>
          <li>develop</li>
        </ul>
        <img src="img/branches.png" alt="" />
        <p class="text">
          Ветвь master создаётся при инициализации репозитория, что должно быть
          знакомо каждому пользователю Git. Параллельно ей также мы создаём
          ветку для разработки под названием develop.
        </p>
        <p class="text">
          Мы считаем ветку origin/master главной. То есть, исходный код в ней
          должен находиться в состоянии production-ready в любой произвольный
          момент времени.
        </p>
        <p class="text">
          Ветвь origin/develop мы считаем главной ветвью для разработки.
          Хранящийся в ней код в любой момент времени должен содержать самые
          последние изданные изменения, необходимые для следующего релиза. Эту
          ветку также можно назвать «интеграционной». Она служит источником для
          сборки автоматических ночных билдов.
        </p>
        <p class="text">
          Когда исходный код в ветви разработки (develop) достигает стабильного
          состояния и готов к релизу, все изменения должны быть определённым
          способом влиты в главную ветвь (master) и помечены тегом с номером
          релиза. Ниже мы рассмотрим этот процесс в деталях.
        </p>
        <p class="text">
          Следовательно, каждый раз, когда изменения вливаются в главную ветвь
          (master), мы по
          <span class="auxiliaryBranches">определению</span> получаем новый
          релиз. Мы стараемся относиться к этому правилу очень строго, так что,
          в принципе, мы могли бы использовать хуки Git, чтобы автоматически
          собирать наши продукты и выкладывать их на рабочие сервера при каждом
          коммите в главную ветвь (master).
        </p>
      </div>
      <div class="auxiliaryBranches">
        <h4>Вспомогательные ветви</h4>
        <p class="text">
          Помимо главных ветвей master и develop, наша модель разработки
          содержит некоторое количество типов вспомогательных ветвей, которые
          используются для распараллеливания разработки между членами команды,
          для упрощения внедрения нового функционала (features), для подготовки
          релизов и для быстрого исправления проблем в производственной версии
          приложения. В отличие от главных ветвей, эти ветви всегда имеют
          ограниченный срок жизни. Каждая из них в конечном итоге рано или
          поздно удаляется.
        </p>
        <p class="text">Мы используем следующие типы ветвей:</p>
        <ul class="ul">
          <li class="li-1">Ветви функциональностей (Feature branches)</li>
          <li class="li-2">Ветви релизов (Release branches)</li>
          <li class="li-1">Ветви исправлений (Hotfix branches)</li>
        </ul>
        <p class="text">
          У каждого типа ветвей есть своё специфическое назначение и строгий
          набор правил, от каких ветвей они могут порождаться, и в какие должны
          вливаться. Сейчас мы рассмотрим их по очереди.
        </p>
        <p class="text">
          Конечно же, с технической точки зрения, у этих ветвей нет ничего
          «специфического». Разбиение ветвей на категории существует только с
          точки зрения того, как они используются. А во всём остальном это
          старые добрые ветви Git.
        </p>
      </div>
      <div class="featureBranches">
        <h4>Ветви функциональностей (feature branches)</h4>
        <p class="text">
          Могут порождаться от: develop <br />
          Должны вливаться в: develop <br />
          Соглашение о наименовании: всё, за исключением master, develop,
          release-* или hotfix-*
        </p>
        <img src="img/small_branches.png" alt="" />
        <p class="text">
          Ветви функциональностей (feature branches), также называемые иногда
          тематическими ветвями (topic branches), используются для разработки
          новых функций, которые должны появиться в текущем или будущем релизах.
          При начале работы над функциональностью (фичей) может быть ещё
          неизвестно, в какой именно релиз она будет добавлена. Смысл
          существования ветви функциональности (feature branch) состоит в том,
          что она живёт так долго, сколько продолжается разработка данной
          функциональности (фичи). Когда работа в ветви завершена, последняя
          вливается обратно в главную ветвь разработки (что означает, что
          функциональность будет добавлена в грядущий релиз) или же удаляется (в
          случае неудачного эксперимента).
        </p>
        <p class="text">
          Ветви функциональностей (feature branches) обычно существуют в
          репозиториях разработчиков, но не в главном репозитории (origin).
        </p>
      </div>
      <div class="featurebranch">
        <h4>Создание ветви функциональности (feature branch)</h4>
        <p class="text">
          При начале работы над новой функциональностью делается ответвление от
          ветви разработки (develop).
        </p>
        <p class="text">
          $ git checkout -b myfeature develop <br />
          Switched to a new branch "myfeature"
        </p>
      </div>
      <div class="continued">
        <p class="text" style="color: red">
          Полную версию статьи читайте
          <a href="https://habr.com/ru/post/106912/">тут</a>
        </p>
      </div>
    </main>
  </body>
</html>
